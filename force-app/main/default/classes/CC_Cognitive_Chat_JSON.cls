public class CC_Cognitive_Chat_JSON {

    //Generated by JSON2Apex http://json2apex.herokuapp.com
    //The supplied json has fields with names that are not valid in apex
    //and so can only be parsed with explicitly generated code, this option
    //was auto selected for you.

    public class ConversationUnits {
        public Integer type_Z {get;set;}
        public String text {get;set;}
        public String timestamp {get;set;}
        public List<Results> results {get;set;}
        public String nickname {get;set;}
        public String id {get;set;}
        public Boolean auto {get;set;}

        public ConversationUnits(JSONParser parser) {
            //Tipos de mensajes
            final List<Integer> typesCliente = new List<Integer>{5, 11, 24};
            final List<Integer> typesChatbotAgente = new List<Integer>{4, 9, 10, 15, 46,183};
            final List<Integer> typesHidden = new List<Integer>{14, 36};

            while (parser.nextToken() != System.JSONToken.END_OBJECT) {
                if (parser.getCurrentToken() == System.JSONToken.FIELD_NAME) {
                    String parserText = parser.getText();
                    if (parser.nextToken() != System.JSONToken.VALUE_NULL) {
                        if (parserText == 'type') {
                            type_Z = parser.getIntegerValue();
                        } else if (parserText == 'text') {
                            this.text = parser.getText();
                        } else if (parserText == 'timestamp') {
                            timestamp = parser.getText();
                        } else if (parserText == 'results') {
                            results = arrayOfResults(parser);
                        } else if (parserText == 'id') {
                            id = parser.getText();
                        } else if (parserText == 'auto') {
                            auto = parser.getBooleanValue();
                        } else {
                            System.debug(LoggingLevel.WARN, 'ConversationUnits consuming unrecognized property: ' + parserText);
                            consumeObject(parser);
                        }
                    }
                }

                if (typesCliente.contains(type_Z)) {
                    nickname = 'Cliente';
                } else if (typesChatbotAgente.contains(type_Z)) {
                    nickname = 'ChatbotAgente';
                }else if (typesHidden.contains(type_Z)) {
                	nickname = 'ChatbotHidden';
                }
            }
        }
    }

    public class Results {
        public String id {get;set;}
        public Double confidence {get;set;}

        public Results(JSONParser parser) {
            while (parser.nextToken() != System.JSONToken.END_OBJECT) {
                if (parser.getCurrentToken() == System.JSONToken.FIELD_NAME) {
                    String text = parser.getText();
                    if (parser.nextToken() != System.JSONToken.VALUE_NULL) {
                        if (text == 'id') {
                            id = parser.getText();
                        } else if (text == 'confidence') {
                            confidence = parser.getDoubleValue();
                        } else {
                            System.debug(LoggingLevel.WARN, 'Results consuming unrecognized property: '+text);
                            consumeObject(parser);
                        }
                    }
                }
            }
        }
    }

    public String user {get;set;}
    public String startTime {get;set;}
    public Long duration {get;set;}
    public Datetime fechaInicio {get;set;}
    public Datetime fechaFin {get;set;}
    public Integer iterations {get;set;}
    public Integer reformulations {get;set;}
    public List<String> areas {get;set;}
    public List<String> userQuery {get;set;}
    public List<ConversationUnits> conversationUnits {get;set;}
    public String revision {get;set;}
    public String centro {get;set;}
    public List<BadClassifications> badClassifications {get;set;}
    public List<String> agents {get;set;}
    public String aplicacionOrigen {get;set;}
    public String conversationID {get;set;}
    public Long currentID {get;set;}
    public String aplicacionCorpus {get;set;}
    public String idioma {get;set;}
    public List<String> idiomasDetectados {get;set;}
    public List<String> errors {get;set;}

    //US475917: Whatsapp > Chat: contexto agente
    //Para guardar sourceAplicacionCorpus y sourceConversationID
    public String sourceAplicacionCorpus {get;set;}
    public String sourceConversationID {get;set;}

    // Cognitivo 360.
    public String perfil {get;set;}
    public List<String> idGlobales {get;set;}
    public List<String> pilotaje {get;set;}

    public CC_Cognitive_Chat_JSON(JSONParser parser) {
        while (parser.nextToken() != System.JSONToken.END_OBJECT) {
            if (parser.getCurrentToken() == System.JSONToken.FIELD_NAME) {
                String text = parser.getText();
                if (parser.nextToken() != System.JSONToken.VALUE_NULL) {
                    if (text == 'user') {
                        user = parser.getText();
                    } else if (text == 'startTime') {
                        startTime = parser.getText();
                        fechaInicio = timestampToDatetime(startTime);
                    } else if (text == 'duration') {
                        //Este dato no sirve, hay que calcular el Datetime fechaFin
                        //mirando el startTime global y el timestamp del último mensaje
                        duration = parser.getLongValue();
                    } else if (text == 'iterations') {
                        iterations = parser.getIntegerValue();
                    } else if (text == 'reformulations') {
                        reformulations = parser.getIntegerValue();
                    } else if (text == 'areas') {
                        areas = arrayOfString(parser);
                    } else if (text == 'userQuery') {
                        userQuery = arrayOfString(parser);
                    } else if (text == 'conversationUnits') {
                        conversationUnits = arrayOfConversationUnits(parser);
                    } else if (text == 'revision') {
                        revision = parser.getText();
                    } else if (text == 'centro') {
                        centro = parser.getText();
                    } else if (text == 'badClassifications') {
                        //badClassifications = arrayOfBadClassifications(parser);
                    } else if (text == 'agents') {
                        agents = arrayOfString(parser);
                    } else if (text == 'aplicacionOrigen') {
                        aplicacionOrigen = parser.getText();
                    } else if (text == 'conversationID') {
                        conversationID = parser.getText();
                    } else if (text == 'currentID') {
                        currentID = parser.getLongValue();
                    } else if (text == 'aplicacionCorpus') {
                        aplicacionCorpus = parser.getText();
                    } else if (text == 'idioma') {
                        idioma = parser.getText();
                    } else if (text == 'idiomasDetectados') {
                        idiomasDetectados = arrayOfString(parser);
                    } else if (text == 'errors') {
                        errors = arrayOfString(parser);
                    } else if (text == 'perfil') {
                        perfil = parser.getText();
                    } else if (text == 'idGlobalList') {
                        idGlobales = arrayOfString(parser);
                    } else if (text == 'pilotaje') {
                        pilotaje = arrayOfString(parser);
                    } else if (text == 'sourceConversationID') {//US475917: Whatsapp > Chat: contexto agente
                        sourceConversationID = parser.getText();
                     } else if (text == 'sourceAplicacionCorpus') {//US475917: Whatsapp > Chat: contexto agente
                        sourceAplicacionCorpus = parser.getText();
                    } else {
                        System.debug(LoggingLevel.WARN, 'CC_Cognitive_Chat_JSON consuming unrecognized property: '+text);
                        consumeObject(parser);
                    }
                }
            }
        }
    }

    public class BadClassifications {
        public BadClassifications(JSONParser parser) {
            while (parser.nextToken() != System.JSONToken.END_OBJECT) {
                if (parser.getCurrentToken() == System.JSONToken.FIELD_NAME) {
                    String text = parser.getText();
                    if (parser.nextToken() != System.JSONToken.VALUE_NULL) {
                        System.debug(LoggingLevel.WARN, 'BadClassifications consuming unrecognized property: '+text);
                        consumeObject(parser);
                    }
                }
            }
        }
    }

    public static CC_Cognitive_Chat_JSON parse(String json) {
        System.JSONParser parser = System.JSON.createParser(json);
        return new CC_Cognitive_Chat_JSON(parser);
    }

    public static void consumeObject(System.JSONParser parser) {
        Integer depth = 0;
        do {
            System.JSONToken curr = parser.getCurrentToken();
            if (curr == System.JSONToken.START_OBJECT ||  curr == System.JSONToken.START_ARRAY) {
                depth++;
            } else if (curr == System.JSONToken.END_OBJECT ||  curr == System.JSONToken.END_ARRAY) {
                depth--;
            }
        } while (depth > 0 && parser.nextToken() != null);
    }

    @TestVisible
    private static List<Results> arrayOfResults(System.JSONParser p) {
        List<Results> res = new List<Results>();
        if (p.getCurrentToken() == null) p.nextToken();
        while (p.nextToken() != System.JSONToken.END_ARRAY) {
            res.add(new Results(p));
        }
        return res;
    }

    private static List<String> arrayOfString(System.JSONParser p) {
        List<String> res = new List<String>();
        if (p.getCurrentToken() == null) p.nextToken();
        while (p.nextToken() != System.JSONToken.END_ARRAY) {
            res.add(p.getText());
        }
        return res;
    }

    private static List<BadClassifications> arrayOfBadClassifications(System.JSONParser p) {
        List<BadClassifications> res = new List<BadClassifications>();
        if (p.getCurrentToken() == null) p.nextToken();
        while (p.nextToken() != System.JSONToken.END_ARRAY) {
            res.add(new BadClassifications(p));
        }
        return res;
    }

    private static List<ConversationUnits> arrayOfConversationUnits(System.JSONParser p) {
        List<ConversationUnits> res = new List<ConversationUnits>();
        if (p.getCurrentToken() == null) p.nextToken();
        while (p.nextToken() != System.JSONToken.END_ARRAY) {
            res.add(new ConversationUnits(p));
        }
        system.debug('DPK - RES -> ' + res);
        return res;
    }

    public List<CC_Cognitive_Chat_JSON.Results> getChatbotFaqs() {
        List<CC_Cognitive_Chat_JSON.Results> faqs = new List<CC_Cognitive_Chat_JSON.Results>();

        for (CC_Cognitive_Chat_JSON.ConversationUnits conversationUnit : conversationUnits) {

            if (conversationUnit.type_Z == 63) {
                faqs = conversationUnit.results;
                break;
            }
        }
        return faqs;
    }

    public Boolean getIsTransfer(){
        Boolean esTransfer = false;
        for (CC_Cognitive_Chat_JSON.ConversationUnits conversationUnit : conversationUnits) {

            if (conversationUnit.text == 'TRANSFER') {
                esTransfer = true;
            }
        }
        return esTransfer;
    }


    @TestVisible
    private String formateaDatetime(Datetime d) {
        return d.format('EEEE') + ', ' + d.format('MMMM') + ' ' + d.day() + ', ' + d.year() + ', ' + d.format('HH:mm:ss');
    }

    @TestVisible
    private Datetime timestampToDatetime(String timestamp) {
        //2019-02-28T11:50:17.923Z --> Thursday, February 28, 2019, 11:50:17
        return Datetime.valueOfGmt(timestamp.replace('T', ' ').substringBefore('.'));
    }

    @TestVisible
    private static String segundosTranscurridos(String timestampInicio, String timestampFin) {

        //Devuelve los segundos transcurridos entre
        if (timestampInicio == null || timestampFin == null) {
            return '0';
        } else {
            Datetime dt1 = Datetime.valueOfGmt(timestampInicio.replace('T', ' ').substringBefore('.'));
            Datetime dt2 = Datetime.valueOfGmt(timestampFin.replace('T', ' ').substringBefore('.'));
            Integer segundos = Integer.valueOf(3600*(dt2.hour() - dt1.hour()) + 60*(dt2.minute() - dt1.minute()) + (dt2.second() - dt1.second()));

            //En ocasiones el JSON incluye mensajes con timestamp anteriores al startDate (provocando mensajes con "-1s")
            if (segundos < 0) {
                segundos = 0;
            }

            if (segundos > 59) {
                return String.valueOf(segundos/60) + ' min ' + String.valueOf(Math.mod(segundos, 60)) + 's';
            } else {

                return String.valueOf(Math.mod(segundos, 60)) + 's';
            }
        }
    }

    public String getChatHTML(String nicknameCliente) {
        List<CC_Cognitive_Chat_JSON.ConversationUnits> mensajes = new List<CC_Cognitive_Chat_JSON.ConversationUnits>();
        List<String> chat = new List<String>(); //Líneas del texto final a retornar

        for (CC_Cognitive_Chat_JSON.ConversationUnits conversationUnit : conversationUnits) {

            if (conversationUnit.nickname != null) {
                //Mensaje de chatbot/agente o de cliente, se añade a la lista
                mensajes.add(conversationUnit);
            }
        }

        if (!mensajes.isEmpty()) {
            /** Si hay mensajes se añade cabecera al principio. Ejemplo de cabecera:
                <p align="center">Chat Started: Thursday, February 28, 2019, 15:47:26 (+0100)</p>
                <p align="center">Chat Origin: Chat</p>
                <p align="center">Agent Jorge H</p> **/

            chat.add('<p align="center">Chat iniciado: ' + formateaDatetime(timestampToDatetime(mensajes[0].timestamp)) + '</p>\n'); //Thursday, February 28, 2019, 11:50:17
            chat.add('<p align="center">Origen del chat: Chat</p>\n');
            chat.add('<p align="center">[Noa]</p>');

            String nickname;
            for (Integer i = 0; i < mensajes.size(); i++) {
                if (mensajes[i].nickname == 'ChatbotAgente') {
                    nickname = '[Noa]';
                } else if (mensajes[i].nickname == 'Cliente') {
                    nickname = nicknameCliente;
                }else if(mensajes[i].nickname == 'ChatbotHidden'){
                     nickname = '[Hidden]';
                }
                /** Ejemplo de mensaje:
                    ( 7s ) Neo : Hola Jorge, ¿cómo puedo ayudarte?<br>
                    ( 13s ) Jorge H: H?<br> **/

                chat.add('( ' + segundosTranscurridos(mensajes[0].timestamp, mensajes[i].timestamp) + ' ) ' + nickname + ': ' + mensajes[i].text + '<br> ');

                if (i == mensajes.size() - 1) {
                    fechaFin = timestampToDatetime(mensajes[i].timestamp);
                }
            }
        }

        return String.join(chat, '');
    }

    //public List<CC_LiveAgent_Cognitive_Chat_Model> getConversacion(String nicknameCliente, Boolean traspasadoAgente) {
    public List<CC_LiveAgent_Cognitive_Chat_Model> getConversacion(String nicknameCliente, Boolean traspasadoAgente, String tipoChat) {

        List<CC_LiveAgent_Cognitive_Chat_Model> chatLista = new List<CC_LiveAgent_Cognitive_Chat_Model>();
        CC_LiveAgent_Cognitive_Chat_Model chat = new CC_LiveAgent_Cognitive_Chat_Model();
        List<CC_LiveAgent_Cognitive_Chat_Model.Mensaje> chatMensajes = new List<CC_LiveAgent_Cognitive_Chat_Model.Mensaje>();

        //Las conversaciones de ChatBot siempre las inicia el cliente
        if (tipoChat == 'Empleados') {
            chat.Inicio = 'Chat iniciado por el empleado el ';
        } else {
            chat.Inicio = 'Chat iniciado por el cliente el ';
        }

        chat.Inicio2 = formateaDatetime(timestampToDatetime(startTime));

        List<CC_Cognitive_Chat_JSON.ConversationUnits> mensajes = new List<CC_Cognitive_Chat_JSON.ConversationUnits>();
        system.debug('DPK size:' + conversationUnits.size());
        for (CC_Cognitive_Chat_JSON.ConversationUnits conversationUnit : conversationUnits) {

            if (conversationUnit.nickname != null) {
                //Mensaje de chatbot/agente o de cliente, se añade a la lista
                mensajes.add(conversationUnit);
            }
        }

        if (!mensajes.isEmpty()) {
            Boolean finalizaCliente = true;

            CC_Chat_Empleado__mdt mdtChat = [SELECT Id, CC_Resultado__c FROM CC_Chat_Empleado__mdt WHERE CC_Tipo_Chat__c = 'Chatbot' LIMIT 1];




            for (Integer i = 0; i < mensajes.size(); i++) {

                CC_LiveAgent_Cognitive_Chat_Model.Mensaje chatMensaje = new CC_LiveAgent_Cognitive_Chat_Model.Mensaje();

                chatMensaje.Id = String.valueOf(i);
                chatMensaje.Hora = segundosTranscurridos(startTime, mensajes[i].timestamp);
                chatMensaje.Texto = mensajes[i].text;
                system.debug('NMA: mensajes[i].nickname: ' + mensajes[i].nickname);
                if (mensajes[i].nickname == 'ChatbotAgente') {
                    chatMensaje.cliente = false;
                    system.debug('NMA: tipoChat: '+ tipoChat);
                    if (tipoChat == 'Empleados') {
                        if (mdtChat != null) {
                            chatMensaje.Nombre = mdtChat.CC_Resultado__c;
                        }
                    }else{
                        chatMensaje.Nombre = '[Noa]';
                    }
                } else if (mensajes[i].nickname == 'Cliente') {
                    chatMensaje.cliente = true;
                    chatMensaje.Nombre = nicknameCliente;
                } else if (mensajes[i].nickname == 'ChatbotHidden') {
                    chatMensaje.hidden = true;
                    chatMensaje.Nombre = '[Hidden]';
                    //chatMensaje.Nombre = nicknameCliente;
                }
                chatMensajes.add(chatMensaje);

                if (i == mensajes.size() - 1) {
                    //El último mensaje determina quién finaliza la transcripción
                    //además de la fecha de fin de la conversación
                    finalizaCliente = chatMensaje.Cliente;

                    fechaFin = timestampToDatetime(mensajes[i].timestamp);
                }
            }

            if (traspasadoAgente) {
                chat.Fin = 'Chat traspasado a agente el ';
            } else if (finalizaCliente) {
                if(tipoChat=='Empleados'){
                	chat.Fin = 'Chat finalizado por el empleado el ';
                }else{
                	chat.Fin = 'Chat finalizado por el cliente el ';
                }
            } else {
                chat.Fin = 'Chat finalizado por el agente el ';
            }

            chat.Fin2 = formateaDatetime(fechaFin);
        }

        chat.Mensajes = chatMensajes;
        chatLista.add(chat);

        return chatLista;
    }
}